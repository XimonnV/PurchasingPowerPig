<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Financial Math Tests</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .test-result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }
        .pass {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .fail {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .test-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .test-details {
            font-size: 0.9em;
            margin-top: 5px;
            font-family: monospace;
        }
        h1 {
            color: #333;
        }
        .summary {
            padding: 15px;
            background: white;
            border-radius: 5px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <h1>Financial Math Unit Tests</h1>
    <div class="summary" id="summary"></div>
    <div id="test-results"></div>

    <!-- Load CONFIG first (required by financial-math.js) -->
    <script src="config.js"></script>

    <!-- Load the actual financial-math.js to test real implementations -->
    <script src="financial-math.js"></script>

    <script>
        // Test framework - all functions are loaded from financial-math.js
        const tests = [];
        let passCount = 0;
        let failCount = 0;

        function test(name, fn) {
            tests.push({ name, fn });
        }

        function assertEquals(actual, expected, message = '') {
            if (actual !== expected) {
                throw new Error(`${message}\nExpected: ${expected}\nActual: ${actual}`);
            }
        }

        function assertApproxEquals(actual, expected, tolerance = 0.001, message = '') {
            if (Math.abs(actual - expected) > tolerance) {
                throw new Error(`${message}\nExpected: ${expected} (±${tolerance})\nActual: ${actual}\nDifference: ${Math.abs(actual - expected)}`);
            }
        }

        function assertTrue(condition, message = '') {
            if (!condition) {
                throw new Error(`Assertion failed: ${message}`);
            }
        }

        // Test Cases

        test('Calculate Balanced Starting Amount', () => {
            // With $100 monthly savings and 7% annual inflation
            const result = calculateBalancedStartAmount(100, 7);
            // Expected: approximately $17,556 (rounds to $18,000)
            assertEquals(result, 18000, 'Should calculate correct balanced starting amount');
        });

        test('Calculate Balanced Savings', () => {
            // With $50,000 starting amount and 7% annual inflation
            const result = calculateBalancedSavings(50000, 7);
            // Monthly rate ≈ 0.565% → monthly savings ≈ $283
            // Should round to $280 (nearest 10)
            assertEquals(result, 280, 'Should calculate correct balanced monthly savings');
        });

        test('Calculate Balanced Inflation Rate (COMPOUND INTEREST)', () => {
            // With $50,000 starting and $280 monthly savings
            const result = calculateBalancedInflation(50000, 280);
            // Monthly rate = 280/50000 = 0.0056 = 0.56%
            // Annual rate = (1.0056)^12 - 1 ≈ 0.0693 = 6.93%
            // Should round to 6.9%
            assertApproxEquals(result, 6.9, 0.15, 'Should calculate compound inflation rate correctly');
        });

        test('Calculate Balanced Inflation - Clamps to Minimum', () => {
            // With $50,000 starting and $100 monthly savings
            const result = calculateBalancedInflation(50000, 100);
            // Monthly rate = 100/50000 = 0.002 = 0.2%
            // Annual rate = (1.002)^12 - 1 ≈ 0.02424 = 2.42%
            // Would be 2.4%, but should clamp to minimum 5%
            assertEquals(result, 5.0, 'Should clamp calculated inflation to minimum of 5%');
        });

        test('Balance State Detection (BALANCED)', () => {
            // Start with known balanced values
            const startAmount = 18000;
            const inflation = 7.0;
            const savings = 100;
            
            // Calculate what balanced values should be for each
            const balancedStart = calculateBalancedStartAmount(savings, inflation);
            const balancedSavings = calculateBalancedSavings(startAmount, inflation);
            const balancedInflation = calculateBalancedInflation(startAmount, savings);
            
            // Check if at least one matches (within tolerance for rounding)
            const startMatches = (startAmount === balancedStart);
            const savingsMatches = (savings === balancedSavings);
            const inflationMatches = Math.abs(inflation - balancedInflation) < 0.15; // Allow for rounding
            
            const isBalanced = startMatches || savingsMatches || inflationMatches;
            
            assertTrue(isBalanced, `System should detect balanced state.\nBalanced Start: ${balancedStart}\nBalanced Savings: ${balancedSavings}\nBalanced Inflation: ${balancedInflation}`);
        });

        test('Balance State Detection (UNBALANCED)', () => {
            // Use clearly unbalanced values
            const startAmount = 10000;
            const inflation = 15.0;
            const savings = 50;
            
            const balancedStart = calculateBalancedStartAmount(savings, inflation);
            const balancedSavings = calculateBalancedSavings(startAmount, inflation);
            const balancedInflation = calculateBalancedInflation(startAmount, savings);
            
            const startMatches = (startAmount === balancedStart);
            const savingsMatches = (savings === balancedSavings);
            const inflationMatches = Math.abs(inflation - balancedInflation) < 0.15;
            
            const isBalanced = startMatches || savingsMatches || inflationMatches;
            
            assertTrue(!isBalanced, 'System should detect unbalanced state');
        });

        test('Zero Inflation Edge Case', () => {
            const result = calculateBalancedStartAmount(100, 0);
            assertEquals(result, 100000, 'Should return max when inflation is 0');
        });

        test('Zero Starting Amount Edge Case', () => {
            const result = calculateBalancedInflation(0, 100);
            assertEquals(result, 7, 'Should return default 7% when starting amount is 0');
        });

        test('Boundary: Max Starting Amount', () => {
            const result = calculateBalancedStartAmount(1000, 5);
            assertTrue(result <= 100000, 'Should not exceed max starting amount');
        });

        test('Boundary: Max Savings', () => {
            const result = calculateBalancedSavings(100000, 20);
            assertTrue(result <= 1000, 'Should not exceed max monthly savings');
        });

        test('Boundary: Inflation Range', () => {
            const result = calculateBalancedInflation(10000, 500);
            assertTrue(result >= 5 && result <= 20, 'Should clamp inflation to 5-20% range');
        });

        test('Round Trip: Start → Savings → Inflation → Start', () => {
            const originalStart = 50000;
            const inflation = 7.0;

            // Calculate balanced savings for this start amount and inflation
            const savings = calculateBalancedSavings(originalStart, inflation);

            // Calculate balanced inflation from start and savings
            const calcInflation = calculateBalancedInflation(originalStart, savings);

            // Calculate balanced start from savings and calculated inflation
            const calcStart = calculateBalancedStartAmount(savings, calcInflation);

            // The recalculated start should be close to original (within rounding tolerance)
            assertApproxEquals(calcStart, originalStart, 2000, 'Round trip calculation should be consistent');
        });

        // Core Interest Rate Conversion Tests

        test('Monthly Compound Rate Conversion', () => {
            // Test converting 12% annual to monthly compound rate
            const annualRate = 0.12; // 12%
            const monthlyRate = getMonthlyCompoundRate(annualRate);

            // Monthly rate should be approximately 0.9489% (0.009489)
            // Verify: (1.009489)^12 ≈ 1.12
            const backToAnnual = Math.pow(1 + monthlyRate, 12) - 1;
            assertApproxEquals(backToAnnual, annualRate, 0.000001,
                `Monthly rate (${(monthlyRate * 100).toFixed(4)}%) should compound back to annual rate (${(annualRate * 100).toFixed(2)}%)`);
        });

        test('Monthly to Annual Rate Conversion', () => {
            // Test converting monthly rate back to annual
            const monthlyRate = 0.01; // 1% per month
            const annualRate = monthlyToAnnualRate(monthlyRate);

            // Annual rate should be (1.01)^12 - 1 ≈ 12.68%
            const expectedAnnual = Math.pow(1.01, 12) - 1;
            assertApproxEquals(annualRate, expectedAnnual, 0.000001,
                `Annual rate should be ${(expectedAnnual * 100).toFixed(2)}%`);
        });

        test('Round Trip: Annual → Monthly → Annual Rate', () => {
            // Test that converting annual to monthly and back preserves the value
            const originalAnnual = 0.07; // 7%
            const monthly = getMonthlyCompoundRate(originalAnnual);
            const backToAnnual = monthlyToAnnualRate(monthly);

            assertApproxEquals(backToAnnual, originalAnnual, 0.000001,
                'Round trip annual→monthly→annual should preserve rate');
        });

        test('Calculate Monthly Inflation Loss', () => {
            // With $50,000 balance and 12% annual inflation
            const balance = 50000;
            const annualInflation = 12; // 12%

            const monthlyLoss = calculateMonthlyInflationLoss(balance, annualInflation);

            // Monthly rate for 12% annual ≈ 0.9489%
            // Loss = 50000 * 0.009489 ≈ $474.45
            const monthlyRate = getMonthlyCompoundRate(annualInflation / 100);
            const expectedLoss = balance * monthlyRate;

            assertApproxEquals(monthlyLoss, expectedLoss, 0.01,
                `Monthly loss should be $${expectedLoss.toFixed(2)}`);
        });

        test('Get Balance State: GROW', () => {
            // When savings exceed inflation loss, pig should grow
            const startAmount = 50000;
            const monthlySavings = 500;
            const annualInflation = 7;

            const state = getBalanceState(startAmount, monthlySavings, annualInflation);

            // Monthly loss ≈ $283, savings = $500, so should grow
            assertEquals(state, 'grow', 'Pig should grow when savings > inflation loss');
        });

        test('Get Balance State: SHRINK', () => {
            // When inflation loss exceeds savings, pig should shrink
            const startAmount = 50000;
            const monthlySavings = 100;
            const annualInflation = 12;

            const state = getBalanceState(startAmount, monthlySavings, annualInflation);

            // Monthly loss ≈ $474, savings = $100, so should shrink
            assertEquals(state, 'shrink', 'Pig should shrink when savings < inflation loss');
        });

        test('Get Balance State: BALANCED', () => {
            // When savings match inflation loss, pig should stay balanced
            const startAmount = 50000;
            const annualInflation = 7;
            // Calculate exact balanced savings for this configuration
            const monthlySavings = calculateBalancedSavings(startAmount, annualInflation);

            const state = getBalanceState(startAmount, monthlySavings, annualInflation);

            assertEquals(state, 'balanced',
                `Pig should be balanced when savings ($${monthlySavings}) match inflation loss`);
        });

        test('isBalanced Function: Balanced Configuration', () => {
            // Test the isBalanced helper function directly
            const startAmount = 50000;
            const inflation = 7.0;
            const savings = calculateBalancedSavings(startAmount, inflation);

            const balanced = isBalanced(startAmount, savings, inflation);

            assertTrue(balanced,
                'isBalanced should return true for balanced configuration');
        });

        test('isBalanced Function: Unbalanced Configuration', () => {
            // Test with clearly unbalanced values
            const startAmount = 10000;
            const savings = 50;
            const inflation = 15.0;

            const balanced = isBalanced(startAmount, savings, inflation);

            assertTrue(!balanced,
                'isBalanced should return false for unbalanced configuration');
        });

        // Bitcoin Power Law Tests

        test('Bitcoin Power Law: Price Calculation for Known Date', () => {
            // Test that getBitcoinPowerLawPrice calculates correctly
            // Using January 1, 2024 as test date
            const testDate = new Date('2024-01-01T00:00:00Z');

            // Calculate expected price manually using new log-based formula
            const genesisDate = new Date('2009-01-03T00:00:00Z');
            const daysSinceGenesis = (testDate - genesisDate) / (1000 * 60 * 60 * 24);
            const C = -17.0161223;
            const D = 5.8451542;
            const expectedPrice = Math.pow(10, C + D * Math.log10(daysSinceGenesis));

            // Get price from function
            const actualPrice = getBitcoinPowerLawPrice(testDate);

            // Prices should match within floating point precision
            assertApproxEquals(actualPrice, expectedPrice, 0.01,
                `Power law price calculation should match formula (${daysSinceGenesis.toFixed(0)} days since genesis, price: $${expectedPrice.toFixed(2)})`);
        });

        test('Bitcoin Power Law: Porkopolis Economics Model Accuracy', () => {
            // Verify the new model produces expected price for Jan 1, 2024
            // Expected: ~$68,513 (Porkopolis Economics median model)
            const testDate = new Date('2024-01-01T00:00:00Z');
            const actualPrice = getBitcoinPowerLawPrice(testDate);

            // Should be approximately $68,513 (within reasonable tolerance)
            assertApproxEquals(actualPrice, 68513, 500,
                `Price for Jan 1, 2024 should be ~$68,513 (Porkopolis model), actual: $${actualPrice.toFixed(2)}`);
        });

        test('Bitcoin Power Law: USD to BTC Conversion Consistency', () => {
            // Test that convertUsdToBtc produces consistent results
            const testDate = new Date('2024-01-01T00:00:00Z');

            // Get the power law price for this date
            const btcPrice = getBitcoinPowerLawPrice(testDate);
            const usdAmount = btcPrice; // Use the actual price as our test amount

            // Convert using the function
            const btcAmount = convertUsdToBtc(usdAmount, testDate);

            // When USD amount equals BTC price, we should get exactly 1.0 BTC
            assertApproxEquals(btcAmount, 1.0, 0.000001,
                `Converting USD amount equal to BTC price should yield 1.0 BTC (price: $${btcPrice.toFixed(2)})`);
        });

        test('Bitcoin Power Law: BTC to USD Conversion Consistency', () => {
            // Test that convertBtcToUsd produces consistent results
            const testDate = new Date('2024-01-01T00:00:00Z');

            // Get the power law price for this date
            const expectedPrice = getBitcoinPowerLawPrice(testDate);

            // Convert 1.0 BTC to USD
            const usdAmount = convertBtcToUsd(1.0, testDate);

            // Should equal the power law price
            assertApproxEquals(usdAmount, expectedPrice, 0.01,
                `Converting 1.0 BTC should yield the power law price ($${expectedPrice.toFixed(2)})`);
        });

        test('Bitcoin Power Law: Round Trip USD → BTC → USD', () => {
            // Test round-trip conversion preserves value
            const testDate = new Date('2025-11-10T00:00:00Z');
            const originalUsd = 100000;

            // Convert USD to BTC and back to USD using actual functions
            const btc = convertUsdToBtc(originalUsd, testDate);
            const backToUsd = convertBtcToUsd(btc, testDate);

            // Should get back the original USD amount (within floating point precision)
            assertApproxEquals(backToUsd, originalUsd, 0.01,
                `Round trip USD→BTC→USD should preserve value ($${originalUsd} → ${btc.toFixed(8)} BTC → $${backToUsd.toFixed(2)})`);
        });

        test('Bitcoin Power Law: Round Trip BTC → USD → BTC', () => {
            // Test round-trip conversion preserves value
            const testDate = new Date('2025-11-10T00:00:00Z');
            const originalBtc = 2.5;

            // Convert BTC to USD and back to BTC using actual functions
            const usd = convertBtcToUsd(originalBtc, testDate);
            const backToBtc = convertUsdToBtc(usd, testDate);

            // Should get back the original BTC amount (within floating point precision)
            assertApproxEquals(backToBtc, originalBtc, 0.000001,
                `Round trip BTC→USD→BTC should preserve value (${originalBtc} BTC → $${usd.toFixed(2)} → ${backToBtc.toFixed(8)} BTC)`);
        });

        test('Bitcoin Power Law: Different Dates Produce Different Prices', () => {
            // Power law should produce increasing prices over time
            const date1 = new Date('2020-01-01T00:00:00Z');
            const date2 = new Date('2024-01-01T00:00:00Z');

            const price1 = getBitcoinPowerLawPrice(date1);
            const price2 = getBitcoinPowerLawPrice(date2);

            // Later date should have higher price
            assertTrue(price2 > price1,
                `Later date should have higher price (2020: $${price1.toFixed(2)} vs 2024: $${price2.toFixed(2)})`);
        });

        test('Calculate Full Pig Capacity in BTC', () => {
            // Test with a known date and verify the calculation
            const testDate = new Date('2024-01-01T00:00:00Z');

            // Get BTC price for this date
            const btcPrice = getBitcoinPowerLawPrice(testDate);

            // Calculate full pig in BTC using the function
            const fullPigBtc = calculateFullPigInBtc(testDate);

            // Manually calculate what it should be: $100,000 / BTC price
            const pigCapacityDollars = 100000; // CONFIG.PIG_CAPACITY_DOLLARS
            const expectedBtc = pigCapacityDollars / btcPrice;

            // Should match within floating point precision
            assertApproxEquals(fullPigBtc, expectedBtc, 0.000001,
                `Full pig should be ${expectedBtc.toFixed(6)} BTC when price is $${btcPrice.toFixed(2)}`);
        });

        test('Full Pig BTC Calculation Uses CONFIG Value', () => {
            // Verify that the function correctly reads CONFIG.PIG_CAPACITY_DOLLARS
            const testDate = new Date('2025-11-11T00:00:00Z');

            // Calculate full pig in BTC
            const fullPigBtc = calculateFullPigInBtc(testDate);

            // Convert back to USD - should equal CONFIG.PIG_CAPACITY_DOLLARS
            const backToUsd = convertBtcToUsd(fullPigBtc, testDate);

            // Should equal $100,000 (CONFIG.PIG_CAPACITY_DOLLARS)
            assertApproxEquals(backToUsd, 100000, 0.01,
                'Converting full pig BTC back to USD should yield $100,000');
        });

        // Cumulative Inflation Factor Tests

        test('Calculate Inflation Loss From Factor', () => {
            // Test scenario: $52,000 saved, factor changes from 1.112 to 1.118
            const totalSavings = 52000;
            const oldFactor = 1.112;
            const newFactor = 1.118;

            // Calculate purchasing power before and after
            const ppBefore = totalSavings / oldFactor; // $46,762.59
            const ppAfter = totalSavings / newFactor;  // $46,511.27

            // Expected loss: $251.32
            const expectedLoss = ppBefore - ppAfter;

            // Calculate using the function
            const actualLoss = calculateInflationLossFromFactor(totalSavings, oldFactor, newFactor);

            // Should match within floating point precision
            assertApproxEquals(actualLoss, expectedLoss, 0.01,
                `Inflation loss should be $${expectedLoss.toFixed(2)}`);
        });

        test('Cumulative Inflation Factor Progression', () => {
            // Test that factor grows correctly over multiple months
            // 7% annual inflation = 0.565% monthly rate
            const annualRate = 0.07;
            const monthlyRate = getMonthlyCompoundRate(annualRate);

            let factor = 1.0;

            // Apply inflation for 24 months (2 years)
            for (let i = 0; i < 24; i++) {
                factor = factor * (1 + monthlyRate);
            }

            // After 2 years at 7% annual, factor should be approximately 1.1449
            // (1.07)^2 = 1.1449
            const expectedFactor = Math.pow(1 + annualRate, 2);

            assertApproxEquals(factor, expectedFactor, 0.0001,
                `After 24 months, factor should be ~${expectedFactor.toFixed(4)}`);
        });

        test('PP Lost Percentage From Cumulative Factor', () => {
            // Test scenario: factor = 1.118 (11.8% cumulative erosion)
            const factor = 1.118;

            // Calculate PP lost percentage: (1 - 1/1.118) * 100
            const ppLost = (1 - 1/factor) * 100;

            // Should be approximately 10.55%
            assertApproxEquals(ppLost, 10.55, 0.1,
                'PP lost should be ~10.55%');
        });

        test('Purchasing Power Calculation From Factor', () => {
            // Test scenario from user example:
            // $52,000 saved with cumulative factor 1.118
            // PP should be $46,511
            const totalSavings = 52000;
            const cumulativeFactor = 1.118;

            const purchasingPower = totalSavings / cumulativeFactor;

            // Expected: $46,511
            assertApproxEquals(purchasingPower, 46511, 20,
                `PP should be ~$46,511 (accounting for timing)`);
        });

        // Run all tests
        function runTests() {
            const resultsDiv = document.getElementById('test-results');
            
            tests.forEach(({ name, fn }) => {
                const resultDiv = document.createElement('div');
                resultDiv.className = 'test-result';
                
                const nameDiv = document.createElement('div');
                nameDiv.className = 'test-name';
                nameDiv.textContent = name;
                resultDiv.appendChild(nameDiv);
                
                try {
                    fn();
                    resultDiv.classList.add('pass');
                    const statusDiv = document.createElement('div');
                    statusDiv.textContent = '✓ PASS';
                    resultDiv.appendChild(statusDiv);
                    passCount++;
                } catch (error) {
                    resultDiv.classList.add('fail');
                    const statusDiv = document.createElement('div');
                    statusDiv.textContent = '✗ FAIL';
                    resultDiv.appendChild(statusDiv);
                    
                    const detailsDiv = document.createElement('div');
                    detailsDiv.className = 'test-details';
                    detailsDiv.textContent = error.message;
                    resultDiv.appendChild(detailsDiv);
                    failCount++;
                }
                
                resultsDiv.appendChild(resultDiv);
            });
            
            // Update summary
            const summaryDiv = document.getElementById('summary');
            summaryDiv.innerHTML = `
                <strong>Test Results:</strong> ${passCount} passed, ${failCount} failed out of ${tests.length} total
                ${failCount === 0 ? '<div style="color: green; margin-top: 10px;">✓ All tests passed!</div>' : ''}
            `;
        }

        // Run tests when page loads
        window.addEventListener('DOMContentLoaded', runTests);
    </script>
</body>
</html>
